# Chapter Checklist

Page Offset: -6

- [x] **Chapter 1: A Tour of Computer Systems** (Page 37)
  - [x] 1.1 Information Is Bits + Context (Page 39)
  - [x] 1.2 Programs Are Translated by Other Programs into Different Forms (Page 40)
  - [x] 2.3 It Pays to Understand How Compilation Systems Work (Page 42)
  - [x] 1.4 Processors Read and Interpret Instructions Stored in Memory (Page 43)
  - [x] 1.5 Caches Matter (Page 47)
  - [x] 1.6 Storage Devices Form a Hierarchy (Page 50)
  - [x] 1.7 The Operating System Manages the Hardware (Page 50)
  - [x] 1.8 Systems Communicate with Other Systems Using Networks (Page 55)
  - [ ] 1.9 Important Themes (Page 58)
  - [ ] 1.10 Summary (Page 63)

- [ ] **Chapter 2: Representing and Manipulating Information** (Page 67)
  - [ ] 2.1 Information Storage (Page 70)
  - [ ] 2.2 Integer Representations (Page 95)
  - [ ] 2.3 Integer Arithmetic (Page 120)
  - [ ] 2.4 Floating Point (Page 144)
  - [ ] 2.5 Summary (Page 162)

- [ ] **Chapter 3: Machine-Level Representation of Programs** (Page 199)
  - [ ] 3.1 A Historical Perspective (Page 202)
  - [ ] 3.2 Program Encodings (Page 205)
  - [ ] 3.3 Data Formats (Page 213)
  - [ ] 3.4 Accessing Information (Page 215)
  - [ ] 3.5 Arithmetic and Logical Operations (Page 227)
  - [ ] 3.6 Control (Page 236)
  - [ ] 3.7 Procedures (Page 274)
  - [ ] 3.8 Array Allocation and Access (Page 291)
  - [ ] 3.9 Heterogeneous Data Structures (Page 301)
  - [ ] 3.10 Combining Control and Data in Machine-Level Programs (Page 312)
  - [ ] 3.11 Floating-Point Code (Page 329)
  - [ ] 3.12 Summary (Page 345)

- [ ] **Chapter 4: Processor Architecture** (Page 387)
  - [ ] 4.1 The Y86-64 Instruction Set Architecture (Page 391)
  - [ ] 4.2 Logic Design and the Hardware Control Language HCL (Page 408)
  - [ ] 4.3 Sequential Y86-64 Implementations (Page 420)
  - [ ] 4.4 General Principles of Pipelining (Page 448)
  - [ ] 4.5 Pipelined Y86-64 Implementations (Page 457)
  - [ ] 4.6 Summary (Page 506)

- [ ] **Chapter 5: Optimizing Program Performance** (Page 531)
  - [ ] 5.1 Capabilities and Limitations of Optimizing Compilers (Page 534)
  - [ ] 5.2 Expressing Program Performance (Page 538)
  - [ ] 5.3 Program Example (Page 540)
  - [ ] 5.4 Eliminating Loop Inefficiencies (Page 544)
  - [ ] 5.5 Reducing Procedure Calls (Page 548)
  - [ ] 5.6 Eliminating Unneeded Memory References (Page 550)
  - [ ] 5.7 Understanding Modern Processors (Page 553)
  - [ ] 5.8 Loop Unrolling (Page 567)
  - [ ] 5.9 Enhancing Parallelism (Page 572)
  - [ ] 5.10 Summary (Page 583)

- [ ] **Chapter 6: The Memory Hierarchy** (Page 615)
  - [ ] 6.1 Storage Technologies (Page 617)
  - [ ] 6.2 Locality (Page 640)
  - [ ] 6.3 The Memory Hierarchy (Page 645)
  - [ ] 6.4 Cache Memories (Page 650)
  - [ ] 6.5 Writing Cache-Friendly Code (Page 669)
  - [ ] 6.6 Putting It Together: The Impact of Caches on Program Performance (Page 675)
  - [ ] 6.7 Summary (Page 684)

- [ ] **Chapter 7: Linking** (Page 705)
  - [ ] 7.1 Compiler Drivers (Page 707)
  - [ ] 7.2 Static Linking (Page 708)
  - [ ] 7.3 Object Files (Page 709)
  - [ ] 7.4 Relocatable Object Files (Page 710)
  - [ ] 7.5 Symbols and Symbol Tables (Page 711)
  - [ ] 7.6 Symbol Resolution (Page 715)
  - [ ] 7.7 Relocation (Page 725)
  - [ ] 7.8 Executable Object Files (Page 731)
  - [ ] 7.9 Loading Executable Object Files (Page 733)
  - [ ] 7.10 Dynamic Linking with Shared Libraries (Page 734)
  - [ ] 7.11 Loading and Linking Shared Libraries from Applications (Page 737)
  - [ ] 7.12 Position-Independent Code (PIC) (Page 740)
  - [ ] 7.13 Library Interpositioning (Page 743)
  - [ ] 7.14 Tools for Manipulating Object Files (Page 749)
  - [ ] 7.15 Summary (Page 749)

- [ ] **Chapter 8: Exceptional Control Flow** (Page 757)
  - [ ] 8.1 Exceptions (Page 759)
  - [ ] 8.2 Processes (Page 768)
  - [ ] 8.3 System Call Error Handling (Page 773)
  - [ ] 8.4 Process Control (Page 774)
  - [ ] 8.5 Signals (Page 792)
  - [ ] 8.6 Nonlocal Jumps (Page 817)
  - [ ] 8.7 Tools for Manipulating Processes (Page 822)
  - [ ] 8.8 Summary (Page 823)

